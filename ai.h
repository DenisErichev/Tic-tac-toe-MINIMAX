/* ai.h – Листинг заголовочного файла проекта                                                                  */
/***************************************************************************************************************/
/* Filename : ai.h                                                                                             */
/* Abstract : Файл содержит  функции для реализации корректной работы бота для игры крестики нолики 5x5        */
/* Description :  Данный программный модуль дает возможность корректной работы "бота"                          */
/* Creation Date : 2022 / 05 / 21                                                                              */
/* Author : Еричев Денис                                                                                       */
/* Notes / Platform / Copyrights : OS Linux, FreeWare                                                          */
/***************************************************************************************************************/
#ifndef AI_H
#define AI_H
#include <iostream>
#include <string>
#include<cstdlib>
using namespace std;
char field[25]={' ',' ',' ',' ',' ',
                ' ',' ',' ',' ',' ',
                ' ',' ',' ',' ',' ',
                ' ',' ',' ',' ',' ',
                ' ',' ',' ',' ',' '};
char first_choice;
char second_choice;
string first_player;
string second_player;
char human_move;
char comp_move;
char crosses='X';
char zeros='0';
int beta = 1000;
int alpha = -1000;
/***************************************************************************************************/
/* Функция: char win(char player)                                                                  */
/* Цель: Проверка выигрышных позиций                                                               */
/* Исходные данные: player- "X" или  "0"                                                           */
/* Вызываемые модули: main.cpp, funcs.h                                                            */
/* Описание алгоритма: Если на поле в ряд пять крестиков или ноликов, то вернуть истину, иначе ложь*/
/* Дата: 2022 / 05 / 21 Версия 1.01                                                                */
/* Автор: Еричев Д.А.                                                                              */
/* Исправления: нет                                                                                */
/***************************************************************************************************/
char win(char player){
    if ((field[0]==player&&field[1]==player&&field[2]==player&&field[3]==player&&field[4]==player)||
        (field[5]==player&&field[6]==player&&field[7]==player&&field[8]==player&&field[9]==player)||
        (field[10]==player&&field[11]==player&&field[12]==player&&field[13]==player&&field[14]==player)||
        (field[15]==player&&field[16]==player&&field[17]==player&&field[18]==player&&field[19]==player)||
        (field[20]==player&&field[21]==player&&field[22]==player&&field[23]==player&&field[24]==player)||
        (field[0]==player&&field[5]==player&&field[10]==player&&field[15]==player&&field[20]==player)||
        (field[1]==player&&field[6]==player&&field[11]==player&&field[16]==player&&field[21]==player)||
        (field[2]==player&&field[7]==player&&field[12]==player&&field[17]==player&&field[22]==player)||
        (field[3]==player&&field[8]==player&&field[13]==player&&field[18]==player&&field[23]==player)||
        (field[4]==player&&field[9]==player&&field[14]==player&&field[19]==player&&field[24]==player)||
        (field[0]==player&&field[6]==player&&field[12]==player&&field[18]==player&&field[24]==player)||
        (field[20]==player&&field[16]==player&&field[12]==player&&field[8]==player&&field[4]==player))
        {
        return true;
        }
        else{
            return false;
        }
}
/***********************************************************************************************************/
/* Функция: bool tie(char field[25])                                                                       */
/* Цель: Проверка поля на занятые ячейки                                                                   */
/* Исходные данные: field[25]- символьный массив, имитирующий игровое поле                                 */
/* Вызываемые модули: main.cpp, funcs.h                                                                    */
/* Описание алгоритма: Циклом for перебираем ячейки поля, если ячейка пуста, то вернуть ложь, иначе истину */
/* Дата: 2022 / 05 / 21 Версия 1.01                                                                        */
/* Автор: Еричев Д.А.                                                                                      */
/* Исправления: нет                                                                                        */
/***********************************************************************************************************/
bool tie(char field[25]){
    for(int i=0;i<25;i++){
        if (field[i]==' '){
            return false;
        }
    }
    return true;
}
/************************************************************************************************************/
/* Функция: int minimax(int depth,char field[25],bool curr_player,int alpha,int beta)                       */                                                    
/* Цель: Последовательный перебор ходов рекурсией, за "X" и "0",если при переборе, выиграл компьютер-       */
/*вернуть +10                                                                                               */
/*если выиграл человек- вернуть -10, если ничья-вернуть 0,если глубина рекурсии равна 7, то вернуть 0       */
/* Исходные данные: depth, char field[25]-поле, curr_player-булевая переменная которая                      */
/*отвечает за текущего игрока(false-ход человека, true-ход компьютера), alpha- глобальная переменная, отвечает*/ 
/*за текущее максимальное значение оценки узла, beta - отвечает за текущее минимальное значение оценки узла  */
/* Вызываемые модули: main.cpp                                                                              */
/* Дата: 2022 / 05 / 21 Версия 1.01                                                                         */
/* Автор: Еричев Д.А.                                                                                       */
/* Исправления: нет                                                                                         */
/************************************************************************************************************/
int minimax(int depth,char field[25],bool curr_player,int alpha,int beta){
    /************************************************************************************************************/
    /*Если глубина рекурсии равна 7, то функция возвращает 0*/
    /*Значение глубины 7, было выбрано, исходя из того, что при полном переборе всех ходов, у компьютера не */
    /*хватает вычислительных средств, и при глубине 7, программа отрабатывает быстро, больше уже долго*/
    if(depth==7){
        return 0;
    }/* Конец if оператора                                                                       */
    /*Если выигрышная позиция у компьютера, то функция возвращает 10*/
    if(win(comp_move)){
        return +10;
    }/* Конец if оператора                                                                       */
    /*Если выигрышная позиция у человека, то функция возвращает -10*/
    if(win(human_move)){
        return -10;
    }/* Конец if оператора                                                                       */
    /*Если ничья, то функция возвращает 0*/
    if(tie(field)){
        return 0;
    }/* Конец if оператора                                                                       */
    /*Если значение истинно, то ход компьютера(false-ход человека, true-ход компьютера)*/
    if(curr_player){  
        int best_score=-1000;
        /* Перебор целочисленного массива на 25 ячеек                                                    */
        /* который является игровым полем 5x5.                                                           */
        for(int i=0;i<25;i++){
            /* Если текущая ячейка пуста                                                    */
            if(field[i]==' '){
                /* В эту ячейку присваивается "X" или "0", в зависимости от того за кого играет компьютер    */
                field[i]=comp_move;
                /* Осуществление рекурсивного вызова функции, с увелечение глубины, передачей значения false- 
                для обозначения хода человека */
                int curr_score=minimax(depth+1,field,false,alpha,beta);
                /* После получения значения curr_score, очищаем ячейку, куда был сделан ход. Важно отметить,*/
                /*что такой подход нужен для оценки каждого хода                                              */
                field[i]=' ';
                /**********************************************************************************************************/
                /* Блок поиска наибольшего счета, на текущем уровне хода компьютера, т.к. компьютер-максимизирубщий игрок,*/
                /*то ищем максимальный счет*/
                if(curr_score>best_score){
                    /*Если условие истино, то меняем лучший счет на текущем уровне*/
                    best_score=curr_score;
                }/* Конец if оператора
                /**********************************************************************************************************/
                /* Блок поиска значения alpha, на текущем уровне хода компьютера, т.к. компьютер-максимизирующий игрок,*/
                /*то ищем максимальный счет*/                                                                       
                if(best_score>alpha){
                    /*Если условие истино, то меняем alpha, как глобальную переменную*/
                    alpha=best_score;
                }/* Конец if оператора
                /*Блок сравнения ранее найденного максимального и минимального значения, если мы нашли на глубине меньше,*\ 
                /*счет больше,то возвращаем максимальнй счет*/                                                                  
                if(alpha>=beta){
                    /*Если условие истино, то возвращаем максимальное значение на предыдущий урвоень*/
                    return alpha;
                }/* Конец if оператора                                                                       */
            }/* Конец if оператора                                                                       */
        }/* Конец for оператора    
        /*Возвращаем максимальный счет на текущем уровне,в предыдущий*/                                                                   
        return best_score;
    }
    else{
        int best_score=1000;
        /* Перебор целочисленного массива на 25 ячеек*/
        /* который является игровым полем 5x5.       */
        for(int i=0;i<25;i++){
            /* Если текущая ячейка пуста                                                    */
            if(field[i]==' '){
                /* В эту ячейку присваивается "X" или "0", в зависимости от того за кого играет человек    */
                field[i]=human_move;
                /* Осуществление рекурсивного вызова функции, с увелечение глубины, передачей значения false- 
                для обозначения хода компьютера */
                int curr_score=minimax(depth+1,field,true,alpha,beta);
                /* После получения значения curr_score, очищаем ячейку, куда был сделан ход. Важно отметить,*/
                /*что такой подход нужен для оценки каждого хода                                              */
                field[i]=' ';
                /* Блок поиска наименьшего счета, на текущем уровне хода человека, т.к. человек-минимизирующий игрок,*/
                /*то ищем минимальный счет*/
                if(curr_score<best_score){
                    /*Если условие истино, то меняем лучший счет на текущем уровне, ищем минимальный*/
                    best_score=curr_score;
                }/* Конец if оператора                                                                       */
                /* Блок сравнения переменных которые отвечают за максимальную оценку и минимальную оценку, найденную 
                /*на данной ветке дерева рекурсии. Так как beta отвечает за минимальное значение, */
                /*то ищем минимальный счет,и меняем глобальную переменную beta*/
                if(best_score<beta){
                    /*Если условие истино, то меняем beta, как глобальную переменную*/
                   beta=best_score;
                }/* Конец if оператора                                                                       */
                /*Блок сравнения ранее найденного максимального и минимального значения, если мы нашли на глубине меньше,*\ 
                /*счет больше,то возвращаем максимальнй счет*/
                if(alpha>=beta){
                    /*Если условие истино, то возвращаем максимальное значение на предыдущий урвоень*/
                    return beta;
                }/* Конец if оператора                                                                       */
            }/* Конец if оператора                                                                       */
        }/* Конец for оператора                                                                      
        /*Возвращаем минимальный счет на текущем уровне,в предыдущий*/    
        return best_score;
    }
}
/************************************************************************************************************/
/* Функция: void computerMove(char comp_choice)                                                             */                                                    
/* Цель: Сделать самый первый ход нашего бота, данную функцию можно рассматривать как корень дерева, в данную*/
/* Исходные данные: comp_choice-"X" или "0", за кого играет наш бот                                          */
/* Вызываемые модули: main.cpp                                                                              */
/* Дата: 2022 / 05 / 21 Версия 1.01                                                                         */
/* Автор: Еричев Д.А.                                                                                       */
/* Исправления: нет                                                                                         */
/************************************************************************************************************/
void computerMove(char comp_choice){
    /* Полученную переменную в качестве аргумента, приравниваем к переменной, отвечающей за ход компьютера("X" или "0") */
    comp_move=comp_choice;
    /* Если полученная переменная- "X",то в переменную отвечающую за ход человека, приравниваем "0") */
    if(comp_choice==crosses) {
        /*Если условие истино, меняем переменную отвечающую за ход человека, приравниваем "0"*/
        human_move=zeros;
    }
    /* Иначе-если полученная переменная- "0",то в переменную отвечающую за ход человека, приравниваем "X") */
    else if(comp_choice==zeros) {
        /*Если условие истино, меняем переменную отвечающую за ход человека, приравниваем "X"*/
        human_move=crosses;
    }
    int best_score=-1000;/*наибольшее значение на текущем уровне*/
    int index=0;
    int depth=0;
    /* Перебор целочисленного массива на 25 ячеек*/
    /* который является игровым полем 5x5.       */
    for(int i=0;i<25;i++){
        /* Если текущая ячейка пуста                                                    */
        if(field[i]==' '){
            /* В эту ячейку присваивается "X" или "0", в зависимости от того за кого играет компьютер    */
            field[i]=comp_move;
            /* Осуществление рекурсивного вызова функции, с увелечение глубины, передачей значения false-*/ 
            /*для обозначения хода человека */
            int curr_score=minimax(depth,field,false,alpha,beta);
            /* После получения значения curr_score, очищаем ячейку, куда был сделан ход. Важно отметить,*/
            /*что такой подход нужен для оценки каждого хода                                              */
            field[i]=' ';
            /* Блок поиска наибольшего счета, на текущем уровне хода компьютера, т.к. компьютер-максимизирубщий игрок,*/
            /*то ищем максимальный счет*/
            /* Блок поиска наибольшего счета, на текущем уровне хода компьютера, т.к. компьютер-максимизирубщий игрок,*/
            /*то ищем максимальный счет*/
            if(curr_score>best_score){
                /*Если условие истино, то меняем лучший счет на текущем уровне*/
                best_score=curr_score;
                /*Запоминаем ячейку с максимальныйм счетом, чтобы сделать туда ход*/
                index=i;
            }/* Конец if оператора                                                                       */
        }/* Конец if оператора                                                                       */
    }/* Конец for оператора                                                                          */
    /*В ячейку, с лучшим счетом, присваиваем ход компьютера*/
    field[index]=comp_move;
}
#endif
